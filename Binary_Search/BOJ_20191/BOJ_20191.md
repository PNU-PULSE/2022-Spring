# BOJ 20191: 줄임말


#문제 링크:

[https://www.acmicpc.net/problem/20191](https://www.acmicpc.net/problem/20191)

#사용한 알고리즘:

슬라이딩 윈도우, 다이나믹 프로그래밍, 이분 탐색

#문제 요약: 

문자열 A에서 몇 개의 문자를 지워서 문자열 B를 만들 수 있으면, B를 A의 줄임말이라고 하자.

문자열 S와 문자열 T가 주어질 때, $F(k)$을 문자열 T를 k번 반복한 문자열이라고 할 때, S가 $F(k)$의 줄임말이 되는 최소의 k을 구해보자. 만약 k이 무한히 커져도 $F(k)$이 S의 줄임말이 되지 못하면 -1을 출력해라

#문제 풀이:

$n, m = length(s), length(t)$라고 정의하자.

우리는 잘 생각해보면 하나의 규칙을 이끌어 낼 수 있다.

- ($F(k)$에서 k가 무한히 커져도 S가 될 수 없는 경우) = (S에는 있고, T에는 없는 문자가 존재하는 경우)다.

밑에 세 가지 풀이 방법이 나오지만 나는 딱 하나만 코드를 짜서 제출했고 100점을 맞았다.

위의 두 방법은 내가 코드를 짠 적은 없다. 그래서 “서브태스크를 긁었을 것이다.”라는 표현은 시간복잡도를 이용해 대략적으로 추측한 것이다.

첫 번째 생각한 풀이 방법은 이분 탐색이다.

- $l, r = 1, n$으로 두고 $F(m = (l + r) / 2)$가 S의 줄임말이 되나 안되나 확인 → m을 바꾸고 다시 확인 → 답을 구함

인데, 시간복잡도가 아마 $O$($m^2nlogn$)이므로 서브태스크로 13점을 긁었을 것이다.

두 번째로 생각한 풀이 방법은 동적 계획법이다.

- $DP[a][b]$ = (현재 S의 문자가 a번째 문자이고, 마지막으로 쓴 문자의 인덱스가 b일 때 최소의 k)

이건 아마 $O(nm)$으로 서브태스크로 34점을 긁었을 것이다.

생각해보니, $DP[a][b]$에서 b는 필요 없다는 것을 깨달았고, 세 번째 생각한 풀이 방법으로 맞았다.

세 번째로 생각한 풀이 방법은 동적 계획법이지만, 전과 다르게 1차원으로 바뀌었다.

- $DP[a]$ = (현재 S의 문자가 a번째 문자일때, 최소의 k)

생각해보면 S의 a번째 문자가 T에 있다고 가정하면,  $DP[a] = (DP[a - 1] + 1) or (DP[a - 1])$ 임을 알 수 있다. 전의 값만 저장해주면 되므로, 굳이 배열을 만들 필요조차 없다. (슬라이딩 윈도우)

풀이 방법으로는

- 1)$cnt$ = 현재까지 최소의 $k$, $p$ = (마지막에 쓴 문자의 인덱스)로 정의하자.
- 2)처음에 $cnt = 1, p = 0$으로 정의하고, T에서 전처리를 해주자.
- 2-1)T의 i번째 인덱스에 문자 a가 있다면, $alphabet[a]$에 i를 밀어 넣자.( 시간복잡도 $O(m)$)
- 3)이제 S를 1번부터 n번까지 탐색해주자.
- 3-1)S의 i번째 문자가 a라고 할 때, 만약 alphabet[a]가 비어있다면 그 문자가 T에 없으므로 $k$가 무한해도 S는 T의 줄임말이 될 수 없다. 그러므로 cnt = -1로 바꾸고 반복문에서 탈출하자.
- 3-2)$alphabet[a]$에는 a가 나오는 문자의 인덱스가 오름차순으로 정렬되어 있다.
- 3-2-1)만약 $alphabet[a][-1] <= p$이면, $cnt$개의 T로 $DP[i]$를 만들 수 없으므로 $cnt$에 1을 더하고, 단어를 하나 더 붙였으므로 $p = alphabet[a][0]$으로 설정하고 다음으로 넘어가자.
- 3-2-2)만약 $alphabet[a][-1] > p$이면, $cnt$개의 T로 $DP[i]$를 만들 수 있다. 그런데 나중을 고려해서 $alphabet[a][m] > p$를 만족하는 최소의 $m$을 찾자. 그런데 어떻게 찾아야 할까? 인덱스가 오름차순으로 정렬되어 있으므로 이분 탐색을 돌려서 $m$을 찾을 수 있다.
- 3-2-3)이제 T의 $m$번째 알파벳을 사용했으므로 $p = m$으로 설정하고 다음으로 넘어가자.
- 4) $cnt$를 출력하자

최악의 시간복잡도는 $O(nlogm + m)$으로, 서브태스크를 모두 통과해 100점을 받았다.
