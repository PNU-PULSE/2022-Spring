# 2146

## 문제 링크

https://www.acmicpc.net/problem/2146

## 알고리즘

bfs를 여러 번 사용하였습니다.

## 문제 요약

2차원 배열이 주어지는데, 대륙은 1, 바다는 0으로 구성됩니다. 대륙은 2개 이상이며, 

대륙들 중에 대륙 2개를 잇는 최소길이의 다리 하나를 놓는 문제입니다.

여러가지 방법이 있을 수 있지만(다른 대륙과 연결하거나 다른 방식의 다리 놓기 등)

우리는 '최소 길이'가 무엇인지에 초점을 두고 풀어야 합니다.

## 풀이

input 함수에서 n과 그에 따른 값들을 입력받습니다.

여기서 '대륙'에 해당하는 경우(1인 경우), queue인 RQ에 해당 위치를 집어넣습니다.



문제를 풀기 위해서는 대륙간의 구별이 필요합니다.

대륙간의 구별을 통해 다른 대륙과 맞닿았는지 판별할 수 있기 때문입니다.

이에 initialize 함수에서 RQ값을 차례대로 꺼내며 처음으로 방문한 곳이라면(visited에 저장) 

setLabel 함수(bfs 입니다.) 를 통해 R에 저장된 값을 변경해줍니다.(label 변수는 1씩 증가.)



이렇게 되면 1대륙, 2대륙, ... (label-1)대륙 형태로 나눠집니다.


결과적으로 대륙의 개수는 label -1 개가 됩니다. 

따라서 label - 1 번 동안 visited를 초기화하고,

bridgeLength 함수(bfs 입니다.)를 실행하여 result 값과 비교하면서 최종 값을 출력하면 됩니다.



*setLabel 함수는 일반적인 bfs 방식이나, 

bridgeLength는 대륙을 먼저 구분하고, 바다쪽으로 한 칸씩 늘려서 탐색하는 방식이기에,

이중 for문을 사용합니다.