## 문제 링크
https://www.acmicpc.net/problem/3019

## 문제 요약
처음과 마지막 열을 연결(대각선 가능)하는 겹치지 않는 파이프의 최대 개수를 구하는 문제이다.

## 문제 풀이
마지막 열의 마지막 행부터 시작해, dfs로 탐색을 시작하였다.

파이프가 아래로 가는 것을 1순위, 가운데를 2순위, 위를 3순위로 정했다. (마지막 행부터 시작했기 때문에)

현재 상태에서 장애물이나 파이프가 없는 곳 중 우선순위가 가장 높은 곳으로 간다. 그리고 현재의 좌표를 스택에 저장해둔다.
```C++
if (m[y + cy[i]][x - 1] == '.') {
  xy.push({x, y});  // stack                
  dfs(x - 1, y + cy[i]);
  break;
}                
```

만약 모두 장애물이나 파이프로 막혀 어떤 곳도 갈 수 없는 상태이면 스택에 저장된 이전 좌표로 돌아가 다시 탐색한다. 
```C++
m[y][x] = 'n'; // 막힌 곳은 n으로 표시하였다.

if (!xy.empty()) {
    x = xy.top().first;
    y = xy.top().second;
    xy.pop();
    dfs(x, y);
}
```

만약 처음 열에 도착한다면, stack을 초기화하고 파이프의 개수를 하나 늘려준다.
```C++
if (x == 0) {
  while (!xy.empty()) xy.pop();
  cnt++;
}
```

이를 마지막 행부터 처음 행까지 반복하면, 파이프의 최대 개수를 구할 수 있다.

아래는 문제의 첫번째 예시에서 위 알고리즘이 탐색하는 과정이다.

```C++
.xx..     .xx..     .xx..     .xx..     .xx..     .xxn.     .xxnn
..x..     ..x..     ..x..     ..x..     ..xo.     ..xon     ..xon
.....  -> .....  -> ...o.  -> ...o.  -> ..ooo  -> ..ooo  -> ..ooo
...x.     ...x.     ..oxo     ..oxo     oooxo     oooxo     oooxo
...x.     ...xn     oo.xn     oo.xn     oo.xn     oo.xn     oo.xn
```
